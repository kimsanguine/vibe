---
title: "하루 600커밋 하는 개발자는 정말 코드를 안 읽을까요?"
date: 2026-02-04
word_count: 18,500
reading_time: 25분
---

# 하루 600커밋 하는 개발자는 정말 코드를 안 읽을까요?

## 들어가며

개발자라면 한 번쯤 이런 생각을 해봤을 거예요. "AI가 코드를 써준다는데, 진짜 믿고 배포해도 될까?" 저도 처음엔 의심했어요. 아무리 Claude나 Codex가 똑똑해도, 결국엔 내가 한 줄 한 줄 읽어보고 이해해야 안심이 되잖아요.

그런데 이 사람은 달랐어요. Peter Steinberger. 10억 개 이상의 디바이스에서 사용되는 PSPDF Kit을 만든 개발자죠. 그는 하루에 600개의 커밋을 하면서도, 자신이 배포하는 코드의 대부분을 읽지 않는다고 솔직하게 말합니다.

"미쳤나?" 싶으시죠? 저도 그랬어요. 그런데 The Pragmatic Engineer의 Gergely Orosz와 나눈 인터뷰를 들어보니, 그에게는 분명한 원칙이 있었어요. 단순히 AI에게 작업을 맡기고 방치하는 게 아니라, 시스템 자체를 "스스로 검증하도록" 설계한다는 거예요.

오늘은 Peter가 13년간 회사를 운영하다가 번아웃으로 3년간 쉬었다가, 2024년 AI 시대에 어떻게 복귀했는지, 그리고 5-10개의 AI 에이전트를 동시에 돌리면서 어떻게 개발하는지를 직접 들어봤어요. 그가 말하는 "Loop 닫기"가 뭔지, PR이 왜 이제 "Prompt Request"인지, 그리고 왜 자신을 더 이상 "개발자"가 아닌 "Builder"라고 부르는지요.

중간중간 저도 "이건 좀 아닌데?" 싶은 부분도 있었어요. 하지만 그의 이야기를 듣다 보면, 우리가 생각하는 "개발"의 개념 자체가 바뀌고 있다는 걸 느끼게 돼요. 한번 같이 들어보시죠.

## Q&A 본문

### Q1. 13년간 운영하던 회사를 놓고 3년이나 쉬셨다고요? 무슨 일이 있었나요?

A. 솔직히 말하면, 완전히 타버렸어요.

Peter는 PSPDF Kit이라는 회사를 13년간 운영했어요. PDF를 앱 안에서 볼 수 있게 해주는 프레임워크인데, 지금 10억 개 이상의 디바이스에서 사용되고 있다고 해요. Adobe나 Apple 같은 곳에서도 쓸 정도로 성공한 거죠.

그런데 13년이라는 시간은 생각보다 깁니다. Peter는 "매일 고객 지원, 버그 수정, 새로운 기능 추가"를 반복하다가 어느 순간 완전히 지쳐버렸다고 해요. 그래서 2021년쯤, 회사 지분을 정리하고 기술에서 완전히 손을 뗐어요. 아예 코딩을 안 하고, 개발 뉴스도 안 보고, 기술 트렌드도 신경 안 썼다고 하더라고요.

"3년간 뭘 하셨어요?"라고 물으니까 Peter가 웃으면서 이렇게 답했어요. "그냥... 쉬었어요. 여행도 하고, 독서도 하고, 뭐 그냥 사람답게 살았죠." 번아웃에서 회복하려면 진짜로 완전히 떨어져 있어야 한다는 걸 몸소 실천한 거예요.

그런데 2024년, 갑자기 복귀했어요. 뭐가 그를 다시 끌어들였을까요? 바로 AI 에이전트였어요. 특히 Claude Code 같은 AI 코딩 도구들이 나오면서 "이건 진짜 다르다"고 느꼈대요. 예전에는 코딩이 "지루한 반복 작업"처럼 느껴졌는데, AI와 함께 하면 "진짜 만들고 싶은 걸 만드는" 느낌이 든다는 거예요.

제가 느끼기엔, Peter는 번아웃 때문에 떠났지만, AI 덕분에 "다시 재미를 찾아서" 돌아온 것 같아요. 그리고 이번에는 예전처럼 혼자 모든 걸 하는 게 아니라, AI를 파트너 삼아서 일하는 방식으로 바뀐 거죠.

**실용적 팁**: 번아웃이 오면 무리해서 버티지 마세요. Peter처럼 완전히 쉬는 게 나을 수도 있어요. 그리고 복귀할 때는 "예전 방식"으로 돌아가지 말고, 새로운 도구와 방식을 찾아보세요. AI 시대는 그런 기회를 줍니다.

### Q2. Claudebot이 뭔가요? 어떤 프로젝트인지 간단히 설명해주세요.

A. 제 개인 AI 비서예요. 그런데 일반적인 챗봇이랑은 좀 달라요.

Peter가 복귀해서 만든 첫 프로젝트가 Claudebot이에요. 이름만 보면 "그냥 Claude API 연결한 챗봇인가?" 싶지만, 실제로는 훨씬 더 깊게 들어가요.

Claudebot은 WhatsApp, Discord, Slack, iMessage 같은 여러 메신저 플랫폼에 연결되어 있어요. 그래서 Peter는 어디서든 메시지 하나만 보내면 AI와 대화할 수 있죠. 근데 여기서 끝이 아니에요. 이 봇은 Peter의 컴퓨터에 **완전한 접근 권한**을 가지고 있어요. 카메라도 켤 수 있고, 홈 자동화 시스템도 컨트롤하고, 음악도 틀 수 있어요.

가장 인상적이었던 건 "온보딩" 방식이에요. 일반 앱은 처음 설치하면 튜토리얼이 뜨잖아요? 근데 Claudebot은 부팅할 때 AI가 스스로 "자기 정체성과 영혼을 생성"한대요. 무슨 말이냐면, AI가 처음 시작할 때 "나는 누구고, 무슨 역할을 하는지"를 스스로 정의한다는 거예요. 약간 SF 영화 같죠?

Peter는 이 프로젝트를 GitHub에 공개했는데, 1주일 만에 GitHub 스타가 100개에서 3,300개로 뛰었다고 해요. 사람들이 "이건 진짜 다르다"고 느낀 거죠.

제가 궁금했던 건, "그럼 보안은 어떡하냐"는 거였어요. Peter의 컴퓨터에 풀 액세스 권한을 가진 AI라니, 뭔가 잘못되면 큰일 나잖아요? Peter는 이렇게 답했어요. "물론 위험해요. 하지만 제가 시스템을 설계할 때 '이 AI가 뭘 할 수 있고, 뭘 못하게 할지'를 명확히 정의했어요. 그리고 모든 액션은 로그로 남고, 제가 검토할 수 있어요."

즉, 신뢰는 하되, 검증은 한다는 거예요. 이게 Peter가 말하는 "Loop 닫기"의 시작이에요.

**구체적 사례**: Claudebot은 Peter가 "오늘 날씨 어때?"라고 물으면 API로 날씨 정보를 가져오는 건 기본이고, "밖에 어두워지면 자동으로 조명 켜줘"처럼 조건부 자동화도 가능해요. 실제로 Peter는 홈 자동화 시스템과 연동해서 쓰고 있다고 하더라고요.

### Q3. 하루 600커밋이요? 그게 정말 가능한 건가요? 뻥 아니에요?

A. 진짜예요. 근데 제가 600번 타이핑한 건 아니에요.

Peter가 어느 날 하루에 600개의 커밋을 했다는 이야기가 나왔을 때, 사람들 반응이 둘로 갈렸어요. "와 대단하다"와 "그거 의미 있는 커밋이 맞아?"

Peter는 후자의 질문을 예상했는지, 이렇게 설명했어요. "맞아요. 600개가 다 의미 있는 커밋은 아니에요. 근데 제 기준에서는 '의미 있음'의 정의가 바뀌었어요."

어떻게 가능했냐고요? 바로 **병렬 에이전트 운영** 때문이에요. Peter는 동시에 5개에서 10개의 AI 에이전트를 돌려요. 한 에이전트가 40분 동안 어떤 기능을 개발하는 동안, Peter는 다른 에이전트에게 또 다른 작업을 시켜요. 그리고 또 다른 에이전트에게 테스트를 시키고, 또 다른 에이전트에게 문서 작성을 시켜요.

구체적으로 이런 식이에요:
- **에이전트 1**: WhatsApp 통합 기능 개발 중 (40분 소요 예상)
- **에이전트 2**: Discord 봇 버그 수정 중 (20분 소요)
- **에이전트 3**: 새 API 엔드포인트 테스트 작성 중
- **에이전트 4**: README 문서 업데이트 중
- **에이전트 5**: 이전에 만든 기능 리팩토링 중

Peter는 각 에이전트가 작업하는 동안 기다리지 않아요. 대신 다른 에이전트로 넘어가서 계속 새로운 작업을 지시해요. 그러다 보면 하루에 수백 개의 작은 커밋이 쌓이는 거죠.

"그럼 그 커밋들이 다 제대로 작동해요?"라고 물으니까 Peter가 웃었어요. "100%는 아니에요. 근데 제가 설계한 시스템에서는 AI가 스스로 테스트하고 검증해요. 그래서 에러가 나면 다른 에이전트가 알아서 고쳐요."

제가 보기엔, 600커밋이 중요한 게 아니라 "병렬로 일하는 방식"이 중요한 것 같아요. 우리가 혼자 일할 땐 한 번에 한 가지만 하잖아요. 근데 AI를 여러 개 돌리면, 마치 팀원 10명이 동시에 일하는 것처럼 되는 거예요.

**주의점**: 병렬 에이전트를 쓴다고 해서 모든 게 완벽하진 않아요. Peter도 말했지만, 에이전트끼리 충돌하거나, 같은 파일을 동시에 수정하려고 할 때가 있어요. 그래서 작업을 잘 나눠야 하고, 어떤 에이전트가 뭘 하는지 추적할 시스템이 필요해요.

### Q4. "Loop 닫기"가 뭔가요? 그게 왜 중요한가요?

A. AI 코딩이 성공하려면, AI가 자기 작업을 스스로 검증할 수 있어야 해요.

Peter가 인터뷰에서 가장 강조한 게 이거예요. "Loop를 닫으세요 (Close the loop)." 처음엔 무슨 말인지 몰랐는데, 설명을 듣고 나니 정말 핵심이더라고요.

일반적으로 우리가 AI한테 코드를 시키면 이렇게 되잖아요:
1. 프롬프트 작성: "로그인 기능 만들어줘"
2. AI가 코드 생성
3. 내가 코드 복사해서 붙여넣기
4. 실행해보고 에러 나면 다시 AI한테 물어봄
5. 다시 코드 받아서 수정

이게 "Loop가 열린" 상태예요. AI가 코드를 만들긴 하는데, 결과를 확인하는 건 사람이 해야 해요. 그래서 AI와 사람 사이를 계속 왔다 갔다 하게 돼요.

Peter가 말하는 "Loop 닫기"는 이래요:
1. 프롬프트 작성: "로그인 기능 만들어줘"
2. AI가 코드 생성
3. **AI가 직접 테스트 실행**
4. **AI가 에러 확인하고 스스로 수정**
5. **AI가 테스트 통과할 때까지 반복**
6. 완료되면 사람한테 알림

차이가 보이시나요? AI가 자기가 만든 코드를 스스로 테스트하고, 문제가 있으면 스스로 고쳐요. 사람은 최종 결과만 보면 돼요.

Peter는 실제로 이렇게 말했어요: "The big secret is to always close the loop. It needs to be able to debug and test itself." (큰 비밀은 항상 Loop를 닫는 거예요. AI가 스스로 디버그하고 테스트할 수 있어야 해요.)

어떻게 가능하냐고요? Codex나 Claude Code 같은 도구를 쓰면 돼요. 이 도구들은 코드를 작성만 하는 게 아니라, 터미널 명령도 실행하고, 파일도 읽고, 테스트도 돌릴 수 있어요. 그래서 진짜로 "자기가 만든 코드를 자기가 검증"할 수 있어요.

**실제 적용 사례**: Peter는 Claudebot에 새 기능을 추가할 때, 이런 식으로 프롬프트를 작성한대요:

```
"WhatsApp 메시지를 받으면 자동으로 Discord로 전달하는 기능을 만들어줘.
그리고 통합 테스트도 작성하고, 테스트가 통과하는지 확인해줘.
테스트 실패하면 코드 수정해서 다시 돌려봐."
```

이렇게 하면 AI가 코드 작성 → 테스트 작성 → 테스트 실행 → 수정 → 재테스트를 혼자서 다 해요. Peter는 그 결과만 보고 "오케이" 하면 되는 거죠.

**주의점**: Loop를 닫으려면 테스트 환경이 잘 갖춰져 있어야 해요. AI가 테스트를 실행할 수 있는 환경, 그리고 테스트 결과를 명확히 알 수 있는 시스템이 필요해요. 그래서 Peter는 "CI/CD보다 로컬 테스트가 더 중요하다"고 말해요.

### Q5. 그럼 코드를 진짜 안 읽어요? 그게 안전한가요?

A. 다 읽진 않지만, 중요한 부분은 읽어요. 그리고 "안전"의 기준이 바뀌었어요.

이게 가장 논쟁적인 부분이에요. Peter는 인터뷰에서 이렇게 말했어요: "Did I read all the code? No, because a lot of code really is just boring plumbing." (모든 코드를 읽었냐고요? 아니요, 대부분의 코드는 그냥 지루한 배관 작업이거든요.)

처음 이 말을 들었을 때 저도 놀랐어요. "배관 작업"이라니? Peter는 이렇게 설명했어요.

요즘 코드의 대부분은 사실 "데이터를 A에서 B로 옮기는" 작업이에요. 예를 들어:
- API에서 JSON 데이터 받아오기
- 그 데이터를 내부 데이터 구조로 변환하기
- 데이터베이스에 저장하기
- 다시 다른 형식으로 변환해서 클라이언트에 보내기

이런 코드들은 "논리적으로 복잡"하지 않아요. 그냥 형식 변환, 에러 처리, null 체크 같은 것들이죠. Peter는 이런 코드를 굳이 한 줄씩 읽을 필요가 없다고 봐요. 왜냐하면:

1. **패턴이 명확해요**: 데이터 변환 코드는 패턴이 정해져 있어요. AI가 만든 코드도 대부분 그 패턴을 따라요.
2. **테스트가 있어요**: AI가 코드를 만들 때 테스트도 같이 만들어요. 테스트만 통과하면 큰 문제 없어요.
3. **에러 핸들링이 있어요**: 혹시 문제가 있어도, 런타임에 에러가 나면 로그로 확인할 수 있어요.

그럼 Peter는 뭘 읽냐고요? **아키텍처**요.

Peter는 "어떤 모듈이 어떤 모듈과 통신하는지", "데이터 흐름이 어떻게 되는지", "어떤 외부 서비스를 쓰는지" 같은 큰 그림에 집중해요. 그리고 핵심 로직, 예를 들어 "AI가 사용자 의도를 파악하는 알고리즘" 같은 건 직접 읽고 검토해요.

**실용적 접근법**: 전부 읽지 말고, 중요도에 따라 차등적으로 읽으세요.
- **100% 읽기**: 보안 관련 코드, 핵심 비즈니스 로직
- **30% 읽기**: 일반적인 기능 구현 (테스트 통과하면 대충 훑어보기)
- **거의 안 읽기**: 데이터 변환, 보일러플레이트 코드 (테스트만 확인)

Peter는 "안전"이라는 게 "모든 코드를 내가 이해하는 것"이 아니라, "시스템이 예상대로 작동하는 것"이라고 봐요. 테스트가 통과하고, 로그가 정상이고, 모니터링에 문제가 없으면 그게 안전한 거예요.

**주의**: 이건 Peter처럼 시스템을 잘 설계할 수 있는 사람이 할 수 있는 방식이에요. 초보자라면 여전히 코드를 읽어가며 배워야 해요. AI가 만든 코드를 읽는 건 "학습 자료"로 아주 좋아요.

### Q6. PR이 "Prompt Request"라고요? 무슨 의미예요?

A. 코드보다 프롬프트가 더 중요해졌어요. 어떻게 만들었는지가 무엇을 만들었는지보다 중요할 때가 있거든요.

이것도 정말 인상적이었어요. Peter는 이제 팀원들이 Pull Request를 올릴 때, 코드보다 **프롬프트**를 먼저 본대요.

기존 PR은 이렇게 생겼죠:
```
제목: 로그인 기능 추가
내용: Facebook OAuth 로그인 기능을 추가했습니다.
- auth.js 파일 생성
- 토큰 검증 로직 추가
- 테스트 케이스 3개 작성
```

이제 Peter가 원하는 PR은 이래요:
```
제목: 로그인 기능 추가
프롬프트: "Facebook OAuth를 사용해서 로그인 기능을 만들어줘.
토큰은 JWT로 발급하고, 만료 시간은 24시간으로 설정해줘.
보안을 위해 HTTPS만 허용하고, CSRF 토큰도 검증해줘.
통합 테스트도 작성하고, README에 사용법도 추가해줘."

사용한 도구: Claude Code
반복 횟수: 3번 (처음 2번은 테스트 실패, 3번째에 성공)
```

왜 프롬프트가 중요하냐고요? 몇 가지 이유가 있어요:

**1. 재현 가능성**
프롬프트가 있으면, 나중에 비슷한 기능이 필요할 때 똑같이 만들 수 있어요. 코드만 있으면 "이 코드가 왜 이렇게 짜여졌는지" 모를 때가 많잖아요.

**2. 의도 파악**
프롬프트를 보면 "무엇을 만들려고 했는지" 명확해요. 코드는 "어떻게 구현되었는지"만 보여주지만, 프롬프트는 "왜 이렇게 만들었는지"를 보여줘요.

**3. 학습**
팀원들이 서로의 프롬프트를 보면서 "아, 이런 식으로 요청하면 더 좋은 결과가 나오는구나" 배울 수 있어요. 프롬프트 엔지니어링 스킬이 팀 전체로 퍼지는 거죠.

Peter는 실제로 이렇게 말했어요: "I'm actually more interested in the prompts than in the code. I ask people to please add the prompts." (저는 사실 코드보다 프롬프트에 더 관심이 있어요. 사람들에게 프롬프트를 꼭 추가해달라고 부탁해요.)

**실제 사례**: Peter의 팀원이 복잡한 에러 처리 로직을 추가했는데, 코드만 봐서는 이해하기 어려웠대요. 그런데 프롬프트를 보니까 이랬어요:

```
"API 호출이 실패했을 때, 3번까지 재시도하고,
각 재시도 사이에 지수 백오프(exponential backoff)를 적용해줘.
그래도 실패하면 사용자에게 친절한 에러 메시지를 보여주고,
Sentry에 에러 로그를 남겨줘."
```

이 프롬프트를 보면, 개발자가 "무엇을 원했는지" 바로 알 수 있어요. 그리고 나중에 비슷한 상황에서 이 프롬프트를 재사용할 수 있죠.

**주의점**: 프롬프트를 공유하는 건 좋지만, 민감한 정보(API 키, 비밀번호 등)가 포함되지 않도록 주의하세요. 프롬프트도 코드만큼 보안에 신경 써야 해요.

### Q7. Codex를 주로 쓰신다고요? Claude Code보다 10배 느린데 왜요?

A. 느려도 거의 항상 맞아요. 저는 속도보다 정확도가 중요해요.

이것도 흥미로웠어요. 대부분 사람들은 "빠른 게 좋다"고 생각하잖아요. 근데 Peter는 달라요.

Peter는 OpenAI의 Codex를 주로 써요. Claude Code도 좋아하지만, 중요한 작업은 Codex에 맡긴대요. 이유가 뭐냐고요?

**정확도**예요. Peter는 "Codex는 느리지만, 첫 번째 시도에서 정확한 답을 줄 확률이 훨씬 높다"고 말해요. 반면 빠른 도구는 여러 번 시도해야 할 때가 많아요.

계산해보면 이래요:
- **빠른 도구**: 5초 × 5번 시도 = 25초
- **Codex**: 50초 × 1번 시도 = 50초

일견 빠른 도구가 이기는 것 같지만, 여기에 "사람이 개입하는 시간"을 더하면 달라져요. 빠른 도구는 매번 프롬프트를 다시 작성하고, 에러를 확인하고, 수정 방향을 제시해야 해요. 이게 생각보다 시간이 오래 걸려요.

Codex는 한 번에 정확하게 하니까, Peter는 그냥 "작업 시작" 버튼만 누르고 다른 일을 해요. 그리고 40분 뒤에 돌아오면 완료되어 있어요.

또 다른 이유는 **대화의 깊이**예요. Peter는 AI와 "대화하며 설계"하는 걸 좋아해요. 바로 "이거 만들어줘"가 아니라, "이런 기능을 만들려고 하는데, 어떻게 설계하는 게 좋을까?" 같은 질문을 먼저 던져요.

Codex는 이런 대화가 잘 돼요. 시스템 아키텍처에 대해 조언도 해주고, 트레이드오프에 대해서도 설명해줘요. Peter는 이런 대화를 통해 "더 나은 설계"를 찾아내요.

**구체적 사례**: Peter가 Claudebot에 "멀티 플랫폼 메시징" 기능을 추가할 때, 처음에 Codex에게 이렇게 물었대요:

```
"WhatsApp, Discord, Slack, iMessage를 모두 지원하려고 해요.
각 플랫폼마다 API가 다른데, 어떻게 추상화하는 게 좋을까요?
어댑터 패턴? 아니면 플러그인 아키텍처?"
```

Codex가 두 방식의 장단점을 설명해주고, Peter의 유즈케이스에는 플러그인 아키텍처가 더 맞다고 추천했대요. 그 조언을 듣고 Peter가 "오케이, 그럼 플러그인 아키텍처로 구현해줘"라고 하니까 Codex가 완벽하게 만들어줬다고 해요.

**실용적 팁**: 도구 선택은 상황에 따라 하세요.
- **빠른 반복이 필요한 작업**: Claude Code, Cursor 같은 빠른 도구
- **정확도가 중요한 작업**: Codex, o1 같은 느리지만 정확한 모델
- **학습 목적**: 대화가 잘 되는 모델 (설명을 잘 해주는 것)

### Q8. 에이전트 5-10개를 동시에 돌린다고요? 어떻게 관리하나요?

A. 각 에이전트마다 명확한 역할을 주고, 충돌하지 않게 작업을 나눠요.

병렬 에이전트 운영이 Peter의 핵심 전략이에요. 근데 이게 생각보다 어려워요. 에이전트끼리 같은 파일을 수정하려고 하면 충돌이 나거든요.

Peter의 방식은 이래요:

**1. 명확한 역할 분담**
각 에이전트에게 "너는 이것만 해"라고 명확히 정해줘요. 예를 들어:
- 에이전트 A: WhatsApp 통합만 담당
- 에이전트 B: Discord 통합만 담당
- 에이전트 C: 테스트 작성만 담당
- 에이전트 D: 문서 작성만 담당
- 에이전트 E: 리팩토링만 담당

이렇게 하면 에이전트들이 다른 파일을 건드려서 충돌 확률이 줄어들어요.

**2. 의존성 관리**
에이전트들이 서로 의존하지 않게 작업을 배치해요. 예를 들어 "A가 끝나야 B가 시작할 수 있다"면, A와 B를 동시에 안 돌려요. 대신 A가 돌아가는 동안 C와 D를 돌려요.

**3. 모니터링 시스템**
Peter는 각 에이전트가 뭘 하는지 추적하는 대시보드 같은 걸 만들었대요. 어떤 에이전트가 어떤 작업을 하고, 진행률이 얼마나 되는지 한눈에 볼 수 있어요.

**4. 실패 대비**
에이전트가 실패할 수도 있어요. 그럴 때를 대비해서, 에이전트가 실패하면 자동으로 "실패 로그"를 남기고 Peter에게 알림을 보내요. Peter는 그 로그를 보고 "뭐가 문제인지" 파악한 다음, 프롬프트를 수정해서 다시 시켜요.

**실제 워크플로우**:
```
아침 9시:
- 에이전트 1: "WhatsApp 메시지 전달 기능 만들어줘" (예상 시간: 40분)
- 에이전트 2: "Discord 봇 이전 버그 고쳐줘" (예상 시간: 20분)
- 에이전트 3: "README 업데이트해줘" (예상 시간: 10분)

9시 10분:
- 에이전트 3 완료, 확인
- 에이전트 4: "API 문서 생성해줘" (예상 시간: 30분)

9시 20분:
- 에이전트 2 완료, 확인
- 에이전트 5: "로그 시스템 리팩토링해줘" (예상 시간: 60분)

9시 40분:
- 에이전트 1 완료, 확인
- 에이전트 4 완료, 확인
- 에이전트 6: "통합 테스트 작성해줘" (예상 시간: 40분)

...
```

이런 식으로 계속 돌아가다 보면, 하루에 수십 개의 작업이 완료돼요. 그게 600커밋으로 이어지는 거죠.

**주의점**: 처음부터 10개 돌리지 마세요. Peter도 처음엔 2-3개로 시작했대요. 익숙해지면 점점 늘려가세요. 그리고 에이전트마다 "로그"를 남기는 시스템을 꼭 만드세요. 나중에 뭐가 잘못됐는지 추적하기 어려워요.

### Q9. 코드 리뷰는 죽었다고 하셨는데, 진짜요? 좀 과격한 거 아닌가요?

A. 좀 도발적으로 말한 거긴 해요. 근데 진짜로 형태는 바뀔 거예요.

Peter가 "Code reviews are dead"라고 말했을 때, 많은 개발자들이 반발했어요. 코드 리뷰는 품질 관리의 핵심인데, 그게 죽었다고?

Peter의 진짜 의미는 이거예요: "전통적인 형태의 코드 리뷰는 필요 없어진다."

기존 코드 리뷰는 이런 것들을 확인했죠:
- 문법 에러
- 스타일 가이드 준수
- 간단한 버그
- 테스트 커버리지
- 문서화

근데 AI 시대에는 이런 것들을 AI가 자동으로 체크해요. 문법 에러? AI가 안 만들어요. 스타일 가이드? AI가 일관되게 지켜요. 간단한 버그? AI가 테스트 돌려서 미리 잡아요.

그럼 사람은 뭘 리뷰하냐고요? **의도와 설계**예요.

새로운 형태의 "리뷰"는 이런 질문들을 던져요:
- "이 기능이 정말 필요한가?"
- "이 아키텍처가 장기적으로 유지보수하기 좋은가?"
- "보안 측면에서 문제는 없나?"
- "사용자 경험에 어떤 영향을 미치나?"

즉, "코드가 잘 짜여졌나"가 아니라 "올바른 것을 만들고 있나"를 리뷰하는 거예요.

Peter는 실제로 팀원들에게 이렇게 요청한대요:
```
코드 리뷰 대신, 이것들을 체크해주세요:
1. 프롬프트가 명확한가?
2. AI가 만든 설계가 우리 아키텍처와 일치하는가?
3. 테스트가 통과했는가?
4. 문서가 업데이트되었는가?
5. 이 변경이 다른 부분에 영향을 미치지 않는가?
```

코드의 "어떻게"보다 "왜"와 "무엇"에 집중하는 거죠.

**논쟁적 관점**: 모든 사람이 Peter의 의견에 동의하진 않아요. 특히 대기업이나 규제가 엄격한 산업(금융, 의료 등)에서는 여전히 코드 한 줄 한 줄 리뷰가 필요할 수 있어요. Peter의 방식은 "빠르게 움직이는 스타트업이나 1인 개발자"에게 더 적합할 수 있어요.

**실용적 중간 지점**: 완전히 코드 리뷰를 없애진 말고, "AI가 자동으로 체크할 수 있는 부분"은 건너뛰고, "사람만 판단할 수 있는 부분"에 집중하세요.

### Q10. "Builder"라고 하셨는데, 개발자랑 뭐가 다른가요?

A. 저는 이제 코드를 직접 쓰는 사람이 아니라, 제품을 만드는 사람이에요.

이게 Peter가 가장 강조하고 싶었던 부분 같아요. 정체성의 변화죠.

예전에는 "나는 개발자야"라고 하면, "코드를 잘 짜는 사람"을 의미했어요. 좋은 개발자는 깔끔한 코드를 쓰고, 성능 최적화를 잘하고, 디자인 패턴을 적재적소에 쓰는 사람이었죠.

근데 AI 시대에는 달라져요. 코드를 잘 쓰는 건 AI도 할 수 있어요. 어쩌면 사람보다 더 잘할 수도 있어요.

그럼 사람의 역할은 뭐냐고요? **비전, 취향, 판단**이에요.

Peter는 자신을 "builder"라고 불러요. Builder는 이런 것들을 해요:
- "어떤 제품을 만들까?" 결정
- "사용자가 뭘 원할까?" 고민
- "이 기능이 정말 필요한가?" 판단
- "이 디자인이 우리 브랜드에 맞나?" 평가
- "어떤 기술 스택을 쓸까?" 선택

코딩은 그 다음이에요. 비전이 정해지면, AI한테 "이렇게 만들어줘"라고 지시하는 거죠.

Peter는 이렇게 비유했어요: "건축가가 집을 설계하면, 건설 노동자들이 실제로 짓잖아요. 저는 이제 건축가예요. AI는 건설 노동자고요. 물론 가끔 제가 직접 벽돌도 쌓지만, 제 주 역할은 설계하는 거예요."

**실제 사례**: Claudebot을 만들 때, Peter가 가장 많은 시간을 쓴 건 "어떤 경험을 제공할까"였대요.

예를 들어, "AI가 부팅할 때 스스로 정체성을 생성한다"는 아이디어는 코드가 아니라 **철학**이에요. Peter는 "AI가 미리 정해진 캐릭터를 갖는 게 아니라, 스스로 정체성을 만들어가는 게 더 재미있겠다"고 생각했어요. 이게 제품 비전이에요.

그 비전을 AI한테 설명하고, "이렇게 구현해줘"라고 하면, AI가 코드를 작성해요. Peter는 그 결과를 보고 "음, 이건 내 취향이 아닌데" 하면서 방향을 조정해요.

**Builder가 갖춰야 할 스킬**:
1. **제품 감각**: 사용자가 뭘 원하는지 아는 능력
2. **시스템 사고**: 큰 그림을 보는 능력
3. **커뮤니케이션**: AI에게 명확히 지시하는 능력 (프롬프트 엔지니어링)
4. **취향**: "좋은 것"과 "나쁜 것"을 구별하는 감각
5. **호기심**: 계속 배우고 실험하는 자세

Peter는 "코딩 스킬"이 여전히 중요하다고 봐요. 근데 그건 "코드를 잘 쓰기 위해서"가 아니라, "AI가 만든 코드가 맞는지 판단하기 위해서"예요.

**미래 전망**: Peter는 앞으로 10년 안에 대부분의 개발자가 "builder"로 전환될 거라고 봐요. 순수하게 "코딩만 하는 사람"은 줄어들고, "제품을 만드는 사람"이 늘어날 거예요. 그리고 그게 더 재미있을 거래요.

## 정리하며

Peter Steinberger의 이야기를 들으면서, 저는 두려움과 설렘을 동시에 느꼈어요.

두려운 건, "내가 지금까지 배운 코딩 스킬이 쓸모없어지는 건 아닐까?"였어요. 하루 600커밋을 하면서도 코드를 안 읽는 개발자라니. 그럼 나는 뭘 해야 하지?

근데 인터뷰를 끝까지 듣고 나니, 설렘이 더 커졌어요. Peter가 하는 일은 예전보다 훨씬 더 **창의적**이에요. 그는 이제 코드의 세부사항에 매몰되지 않고, 진짜로 "만들고 싶은 것"에 집중할 수 있어요. 13년간 번아웃을 겪었던 사람이, AI 덕분에 다시 즐겁게 일하고 있어요.

핵심을 정리하면 이래요:

**1. Loop를 닫으세요**
AI가 자기 작업을 스스로 검증할 수 있게 시스템을 설계하세요. 그게 AI 코딩 성공의 비밀이에요.

**2. 프롬프트를 공유하세요**
코드보다 프롬프트가 더 중요해질 수 있어요. 어떻게 만들었는지 기록하고 공유하세요.

**3. 병렬로 생각하세요**
한 번에 한 가지만 하지 마세요. AI를 여러 개 돌려서 동시에 여러 작업을 진행하세요.

**4. 큰 그림을 보세요**
코드 한 줄 한 줄보다, 시스템 아키텍처와 제품 비전에 집중하세요.

**5. Builder가 되세요**
코더에서 Builder로 정체성을 바꾸세요. 코드는 AI가 쓰게 하고, 당신은 "무엇을 만들지" 결정하세요.

Peter의 방식이 모든 사람에게 맞는 건 아니에요. 당신이 대기업에서 일한다면, 혹은 규제가 엄격한 산업에 있다면, 여전히 코드 리뷰가 필요할 수 있어요. 초보 개발자라면, 여전히 코드를 읽고 배워야 해요.

근데 한 가지는 확실해요. AI와 함께 일하는 방식은 계속 진화할 거예요. 그리고 그 변화를 두려워하기보다는, Peter처럼 즐기는 사람이 더 재미있게 일할 거예요.

마지막으로 Peter가 한 말을 공유할게요:

"AI 에이전트 시대에 중요한 건 기술력이 아니라 호기심이에요. '이걸 AI로 할 수 있을까?' 궁금해하는 사람이 가장 먼저 새로운 걸 만들어낼 거예요."

다음 뉴스레터에서는 Peter가 실제로 사용하는 프롬프트 템플릿과, Claudebot을 직접 써본 사용자들의 후기를 가져올게요. 기대해주세요!

## 추천 리소스

**Peter Steinberger 관련**
- Claudebot GitHub: github.com/steipete/Claudebot
- Peter의 트위터: @steipete
- The Pragmatic Engineer 인터뷰 원본: (팟캐스트 링크)

**AI 코딩 도구**
- Codex: OpenAI의 코딩 에이전트
- Claude Code: Anthropic의 개발자 도구
- Cursor: AI 기반 코드 에디터

**학습 자료**
- "Agentic Engineering" - AI 에이전트 활용 개발 방법론
- "Prompt Engineering for Developers" - 개발자를 위한 프롬프트 작성법
- "Loop Closing Patterns" - AI 자동 검증 시스템 설계 패턴

**커뮤니티**
- AI Developers Discord
- Claudebot 사용자 포럼
- Agentic Engineering 스터디 그룹

---

*이 뉴스레터가 도움이 되셨나요? 댓글로 여러분의 AI 코딩 경험을 공유해주세요. 다음 주에 뵙겠습니다!*